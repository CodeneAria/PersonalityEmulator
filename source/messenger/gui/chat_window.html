<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Chat Window</title>
<style>
body {
  font-family: Meiryo, sans-serif;
  margin: 0;
  padding: 10px;
}

#messages {
  border: 1px solid #aaa;
  height: 400px;
  overflow-y: auto;
  padding: 6px;
}

.message {
  display: flex;
  margin-bottom: 4px;
}

.sender {
  width: 100px;
  font-weight: bold;
  border: 1px solid #ccc;
  margin-right: 6px;
  padding: 2px 4px;
}

.text {
  flex: 1;
  border: 1px solid #ddd;
  padding: 4px;
  white-space: pre-wrap;
}

#input {
  margin-top: 10px;
  display: flex;
  gap: 6px;
}
</style>
</head>

<body>

<div id="messages"></div>

<div id="input">
  <input id="sender" placeholder="話者 / Speaker" style="width:100px">
  <textarea id="text" rows="3" style="flex:1"></textarea>
   <button onclick="sendMessage()">送信 / Send</button>
   <button id="voice-btn" style="width:80px">音声入力 / Voice Input</button>
   <button id="stop-btn" style="width:80px">発声停止 / Stop Speak</button>
</div>

<script>
let messageElements = new Map(); // Map message ID to DOM element

async function fetchMessages() {
  const res = await fetch("/messages");
  const data = await res.json();

  for (const msg of data) {
    if (messageElements.has(msg.id)) {
      // Update existing message text if changed
      updateMessage(msg.id, msg.text);
    } else {
      // Add new message
      addMessage(msg.id, msg.sender, msg.text);
    }
  }
}

function addMessage(id, sender, text) {
  const div = document.createElement("div");
  div.className = "message";
  div.dataset.messageId = id;

  div.innerHTML = `
    <div class="sender">${sender}</div>
    <div class="text"></div>
  `;
  const textElement = div.querySelector(".text");
  textElement.textContent = text;

  const messagesContainer = document.getElementById("messages");
  messagesContainer.appendChild(div);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  messageElements.set(id, textElement);
}

function updateMessage(id, text) {
  const textElement = messageElements.get(id);
  if (textElement && textElement.textContent !== text) {
    textElement.textContent = text;
    
    // Auto-scroll to bottom if user is near the bottom
    const messagesContainer = document.getElementById("messages");
    const isNearBottom = messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 100;
    if (isNearBottom) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }
}

async function sendMessage() {
  const sender = document.getElementById("sender").value.trim();
  const text = document.getElementById("text").value.trim();
  if (!text) return;

  await fetch("/messages", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sender, text, source: "chat" })
  });

  document.getElementById("text").value = "";
}

setInterval(fetchMessages, 500);

// Voice input button: active only while pressed (mouse or touch)
const voiceBtn = document.getElementById('voice-btn');
let voiceActive = false;

function setVoiceActive(active) {
  if (voiceActive === active) return;
  voiceActive = active;
  if (voiceActive) {
    voiceBtn.style.background = '#4CAF50';
    voiceBtn.style.color = 'white';
  } else {
    voiceBtn.style.background = '';
    voiceBtn.style.color = '';
  }

  // Notify server of state change
  fetch('/voice_input_state', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ active: voiceActive })
  }).catch(() => {
    // ignore network errors for now
  });
}

// Mouse events
voiceBtn.addEventListener('mousedown', () => setVoiceActive(true));
voiceBtn.addEventListener('mouseleave', () => setVoiceActive(false));

// Touch events for mobile
voiceBtn.addEventListener('touchstart', (e) => { e.preventDefault(); setVoiceActive(true); }, { passive: false });

// Stop speak button: active only while pressed (mouse or touch)
const stopBtn = document.getElementById('stop-btn');
let stopActive = false;

function setStopActive(active) {
  if (stopActive === active) return;
  stopActive = active;
  if (stopActive) {
    stopBtn.style.background = '#f44336';
    stopBtn.style.color = 'white';
  } else {
    stopBtn.style.background = '';
    stopBtn.style.color = '';
  }

  // Notify server of state change
  fetch('/voice_output_stop_flag', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ stop: stopActive })
  }).catch(() => {
    // ignore network errors for now
  });
}

// Mouse events
stopBtn.addEventListener('mousedown', () => setStopActive(true));
stopBtn.addEventListener('mouseleave', () => setStopActive(false));

// Touch events for mobile
stopBtn.addEventListener('touchstart', (e) => { e.preventDefault(); setStopActive(true); }, { passive: false });

// Global mouseup and touchend handlers for both buttons
document.addEventListener('mouseup', () => {
  setVoiceActive(false);
  setStopActive(false);
});
document.addEventListener('touchend', () => {
  setVoiceActive(false);
  setStopActive(false);
});
document.addEventListener('touchcancel', () => {
  setVoiceActive(false);
  setStopActive(false);
});

setInterval(fetchMessages, 500);
</script>

</body>
</html>
