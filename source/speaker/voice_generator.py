"""Voice generation module with pluggable voice synthesis engines."""
from __future__ import annotations

import os
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parents[1]))
sys.path.append(str(Path(__file__).resolve().parents[2]))

from typing import Union, Optional
from flask import Flask, request, jsonify, send_file
import io

from config.communcation_settings import (
    VOICE_GENERATOR_PORT,
    HOSTNAME,
)
from source.speaker.voicevox.voicevox_communicator import (
    VoiceSynthesizerInterface,
    VoicevoxCommunicator,
)


class VoiceGenerator:
    """Class for generating voice audio data with pluggable synthesis engines.

    This class manages text inputs and their corresponding WAV binary data
    generated by any voice synthesis engine that implements VoiceSynthesizerInterface.
    """

    def __init__(self, synthesizer: Optional[VoiceSynthesizerInterface] = None):
        """Initialize VoiceGenerator.

        Args:
            synthesizer: Voice synthesis engine to use. If None, uses VoicevoxCommunicator.
        """
        self.synthesizer = synthesizer if synthesizer is not None else VoicevoxCommunicator()
        self.text_queue: list[str] = []
        self.audio_data_queue: list[bytes] = []

    def generate_push_voice(self, text: Union[str, list[str]]) -> None:
        """Generate voice audio from text and store in queues.

        Accepts a single text string or a list of text strings,
        generates corresponding WAV binary data using the configured synthesizer,
        and appends both text and audio data to internal queues.

        Args:
            text: Single text string or list of text strings to convert to voice.
        """
        # Convert single string to list for uniform processing
        if isinstance(text, str):
            text_list = [text]
        else:
            text_list = text

        # Process each text
        for txt in text_list:
            # Skip empty strings
            if not txt or txt.strip() == "":
                continue

            # Use synthesizer to generate audio
            audio_bytes = self.synthesizer.synthesize(txt)

            if audio_bytes is not None:
                # Store text and audio data
                self.text_queue.append(txt)
                self.audio_data_queue.append(audio_bytes)
            else:
                print(
                    f"[VoiceGenerator] Failed to generate voice for text '{txt}'")

    def get_audio_queue(self) -> list[bytes]:
        """Get the list of generated audio data.

        Returns:
            List of WAV binary data.
        """
        return self.audio_data_queue.copy()

    def get_text_queue(self) -> list[str]:
        """Get the list of text inputs.

        Returns:
            List of text strings.
        """
        return self.text_queue.copy()

    def clear_queues(self) -> None:
        """Clear both text and audio data queues."""
        self.text_queue.clear()
        self.audio_data_queue.clear()

    def pop_audio(self) -> tuple[str, bytes] | None:
        """Pop the oldest text and audio data from queues.

        Returns:
            Tuple of (text, audio_bytes) if queues are not empty, None otherwise.
        """
        if self.text_queue and self.audio_data_queue:
            text = self.text_queue.pop(0)
            audio = self.audio_data_queue.pop(0)
            return (text, audio)
        return None

    def __len__(self) -> int:
        """Return the number of items in the queues.

        Returns:
            Number of items in the queues.
        """
        return len(self.audio_data_queue)

    def is_empty(self) -> bool:
        """Check if queues are empty.

        Returns:
            True if queues are empty, False otherwise.
        """
        return len(self.audio_data_queue) == 0


# Flask app for HTTP server
app = Flask(__name__)
voice_generator = VoiceGenerator()


@app.route('/generate', methods=['POST'])
def generate_voice():
    """Endpoint to generate voice from text.

    Request JSON format:
        {"text": "string"} or {"text": ["string1", "string2", ...]}

    Response JSON format:
        {"status": "success", "count": number_of_generated_audio}
    """
    try:
        data = request.get_json()
        if not data or 'text' not in data:
            return jsonify({"status": "error", "message": "Missing 'text' field"}), 400

        text = data['text']
        voice_generator.generate_push_voice(text)

        return jsonify({
            "status": "success",
            "count": len(voice_generator)
        }), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route('/get_audio', methods=['GET'])
def get_audio():
    """Endpoint to get the oldest audio data from queue.

    Response:
        WAV binary data or JSON error message if queue is empty.
    """
    result = voice_generator.pop_audio()
    if result is None:
        return jsonify({"status": "error", "message": "Queue is empty"}), 404

    text, audio_bytes = result

    # Return WAV binary data
    return send_file(
        io.BytesIO(audio_bytes),
        mimetype='audio/wav',
        as_attachment=True,
        download_name='voice.wav'
    )


@app.route('/queue_status', methods=['GET'])
def queue_status():
    """Endpoint to get current queue status.

    Response JSON format:
        {"count": number_of_items, "is_empty": boolean}
    """
    return jsonify({
        "count": len(voice_generator),
        "is_empty": voice_generator.is_empty()
    }), 200


@app.route('/clear', methods=['POST'])
def clear_queue():
    """Endpoint to clear all queues.

    Response JSON format:
        {"status": "success"}
    """
    voice_generator.clear_queues()
    return jsonify({"status": "success"}), 200


if __name__ == '__main__':
    app.run(host=HOSTNAME, port=VOICE_GENERATOR_PORT, debug=False)
